# Abstract Factory Pattern

- **Refactoring Guru – Abstract Factory**: [https://sourcemaking.com/design_patterns/abstract_factory](https://sourcemaking.com/design_patterns/abstract_factory)
- **Abstract Factory in Python (Hindi)**: [https://www.youtube.com/watch?v=PpKvPrl_gRg](https://www.youtube.com/watch?v=PpKvPrl_gRg)

#### 2.1. What is the Abstract Factory Pattern?

> **Provide an interface for creating families of related or dependent objects without specifying their concrete classes.**

The **Abstract Factory** pattern provides a way to create families of related objects without specifying their concrete classes.

It's a **creational pattern** that promotes:

- **Loose coupling**
- **Open/Closed Principle**
- **Extensibility**

#### 2.2. Why use Abstract Factory?

| Benefit                         | Explanation                                   |
| ------------------------------- | --------------------------------------------- |
| **Avoid tight coupling**        | Client doesn't need to know concrete classes  |
| **Open for extension**          | Add new product types without changing client |
| **Encapsulate object creation** | Creation logic in one place                   |
| **Better testability**          | Mock factories easily                         |
| **Supports polymorphism**       | Return different objects via same interface   |

#### 2.3. When to use Abstract Factory?

Use it when:

- You need to create families of related objects
- You want to **localize** object creation logic
- You want **subclasses** to decide what to instantiate
- You're building a **framework** or **library**

#### 2.4. Real-Life Example:

A **UI framework** supports:

- Windows buttons
- macOS buttons
- Linux buttons

Each platform creates its own button via a **abstract factory**.

#### 2.5. Structure of Abstract Factory

```text
Client
   |
Creator (abstract)
   ├── create_button() → returns Button
   │
   ├── ConcreteCreatorA → overrides create_button() → returns WindowsButton
   └── ConcreteCreatorB → overrides create_button() → returns MacButton

Button (interface)
   ├── ConcreteButtonA
   └── ConcreteButtonB
```

#### 2.6. Python Example: Cross-Platform UI Family

```python
from abc import ABC, abstractmethod

# Product Interfaces
class Button(ABC):
    @abstractmethod
    def render(self) -> str:
        pass

class Checkbox(ABC):
    @abstractmethod
    def check(self) -> str:
        pass

# Concrete Products - Windows
class WindowsButton(Button):
    def render(self) -> str:
        return "Rendering Windows button"

class WindowsCheckbox(Checkbox):
    def check(self) -> str:
        return "Windows checkbox checked"

# Concrete Products - Mac
class MacButton(Button):
    def render(self) -> str:
        return "Rendering macOS button"

class MacCheckbox(Checkbox):
    def check(self) -> str:
        return "macOS checkbox checked"

# Abstract Factory
class GUIFactory(ABC):
    @abstractmethod
    def create_button(self) -> Button:
        pass

    @abstractmethod
    def create_checkbox(self) -> Checkbox:
        pass

# Concrete Factories
class WindowsFactory(GUIFactory):
    def create_button(self) -> Button:
        return WindowsButton()

    def create_checkbox(self) -> Checkbox:
        return WindowsCheckbox()

class MacFactory(GUIFactory):
    def create_button(self) -> Button:
        return MacButton()

    def create_checkbox(self) -> Checkbox:
        return MacCheckbox()

# Client
class Application:
    def __init__(self, factory: GUIFactory):
        self.button = factory.create_button()
        self.checkbox = factory.create_checkbox()

    def render(self):
        return f"{self.button.render()} | {self.checkbox.check()}"

# Usage
factory = WindowsFactory()  # or MacFactory()
app = Application(factory)
print(app.render())
```

#### 2.7. Abstract Factory vs Factory Method – What's the difference?

| Aspect           | Abstract Factory                 | Factory Method                              |
| ---------------- | -------------------------------- | ------------------------------------------- |
| **Goal**         | Create related product families  | Defer single product creation to subclasses |
| **Returns**      | Multiple related products        | One product                                 |
| **Pattern Type** | Object composition of factories  | Inheritance-based factory method            |
| **Example**      | `GUIFactory → Button + Checkbox` | `Dialog.create_button()`                    |

#### 2.8. Advantages and Disadvantages of Abstract Factory

| Advantage                  | Description                        |
| -------------------------- | ---------------------------------- |
| **Decentralized creation** | Each subclass controls its product |
| **Extensible**             | Add new types via new subclasses   |
| **Supports OCP**           | No need to modify existing code    |
| **Framework-friendly**     | Great for libraries/SDKs           |

| Drawback                 | Explanation                  |
| ------------------------ | ---------------------------- |
| **Class explosion**      | One creator per product type |
| **Complexity**           | Overkill for simple cases    |
| **Inheritance required** | Forces class hierarchy       |

