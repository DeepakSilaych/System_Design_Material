# Prototype Pattern

- **Refactoring Guru – Prototype Pattern**: [https://refactoring.guru/design-patterns/prototype](https://refactoring.guru/design-patterns/prototype)
- **Prototype Pattern in Python (Hindi)**: [https://www.youtube.com/watch?v=PpKvPrl_gRg](https://www.youtube.com/watch?v=PpKvPrl_gRg)

#### 4.1. What is the Prototype Pattern?

> **Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.**

The **Prototype** pattern clones existing objects instead of creating from scratch. Useful when object creation is expensive or complex.

#### 4.2. Why use Prototype?

| Benefit                      | Explanation                               |
| ---------------------------- | ----------------------------------------- |
| **Performance**              | Clone instead of reconstructing           |
| **Decouple from classes**    | Create via interface, not concrete class  |
| **Runtime configuration**    | Register and clone prototypes dynamically |
| **Avoid subclass explosion** | Configure via state rather than types     |

#### 4.3. When to use Prototype?

- Object creation is costly or involves complex graph
- Need to create many similar objects
- Want to avoid factories for dynamic types
- Need copies (snapshots) with modifications

#### 4.4. Structure of Prototype

```text
Prototype (interface) ── clone()
   ├── ConcretePrototypeA
   └── ConcretePrototypeB

PrototypeRegistry (optional) ── register(key, proto), clone(key)
```

#### 4.5. Python Example: Cloning with Registry

```python
import copy

class Document:
    def __init__(self, title, pages, metadata=None):
        self.title = title
        self.pages = pages  # list of strings
        self.metadata = metadata or {}
    def clone(self, deep: bool = True):
        return copy.deepcopy(self) if deep else copy.copy(self)
    def __repr__(self):
        return f"Document(title={self.title}, pages={len(self.pages)}, meta={self.metadata})"

class PrototypeRegistry:
    def __init__(self):
        self._prototypes = {}
    def register(self, key: str, prototype: object):
        self._prototypes[key] = prototype
    def clone(self, key: str, deep: bool = True, **attrs):
        if key not in self._prototypes:
            raise KeyError(f"No prototype for key: {key}")
        obj = self._prototypes[key].clone(deep=deep)
        for k, v in attrs.items():
            setattr(obj, k, v)
        return obj

# Usage
registry = PrototypeRegistry()
base = Document("Report", ["p1", "p2"], {"author": "Alice"})
registry.register("report", base)

copy1 = registry.clone("report", title="Q1 Report")         # deep clone
copy2 = registry.clone("report", deep=False, title="Draft") # shallow clone
```

#### 4.6. Shallow vs Deep Copy in Python

| Aspect         | Shallow (`copy.copy`) | Deep (`copy.deepcopy`)          |
| -------------- | --------------------- | ------------------------------- |
| Nested objects | Shared references     | Fully cloned graph              |
| Performance    | Faster                | Slower                          |
| Safety         | Risky with mutables   | Safer, but watch custom objects |

#### 4.7. Advantages and Disadvantages of Prototype

| Advantage               | Description                        |
| ----------------------- | ---------------------------------- |
| **Fast creation**       | Skip repeated setup                |
| **Runtime flexibility** | Register/clone without new classes |
| **Decoupling**          | Client unaware of concrete classes |

| Drawback             | Explanation                                  |
| -------------------- | -------------------------------------------- |
| **Clone complexity** | Cycles, external resources, descriptors      |
| **Copy semantics**   | Must choose shallow vs deep carefully        |
| **Hidden coupling**  | Prototypes can carry unintended shared state |

