# Factory Method Pattern

- **Refactoring Guru – Factory Method**: [https://refactoring.guru/design-patterns/factory-method](https://refactoring.guru/design-patterns/factory-method)
- **Factory Method in Python (Hindi)**: [https://www.youtube.com/watch?v=dMK4TbG29fk](https://www.youtube.com/watch?v=dMK4TbG29fk)

#### 1. What is the Factory Method Pattern?

> **Define an interface for creating an object, but let subclasses decide which class to instantiate.**

The **Factory Method** allows a class to **defer instantiation** to its **subclasses**.

It's a **creational pattern** that promotes:

- **Loose coupling**
- **Open/Closed Principle**
- **Extensibility**

#### 2. Why use Factory Method?

| Benefit                         | Explanation                                   |
| ------------------------------- | --------------------------------------------- |
| **Avoid tight coupling**        | Client doesn't need to know concrete classes  |
| **Open for extension**          | Add new product types without changing client |
| **Encapsulate object creation** | Creation logic in one place                   |
| **Better testability**          | Mock factories easily                         |
| **Supports polymorphism**       | Return different objects via same interface   |

#### 3. When to use Factory Method?

Use it when:

- A class **cannot anticipate** the type of objects it needs to create
- You want to **localize** object creation logic
- You want **subclasses** to decide what to instantiate
- You're building a **framework** or **library**

#### Real-Life Example:

A **UI framework** supports:

- Windows buttons
- macOS buttons
- Linux buttons

Each platform creates its own button via a **factory method**.

#### Structure of Factory Method

```text
Client
   |
Creator (abstract)
   ├── factory_method() → returns Product
   │
   ├── ConcreteCreatorA → overrides factory_method() → returns ConcreteProductA
   └── ConcreteCreatorB → overrides factory_method() → returns ConcreteProductB

Product (interface)
   ├── ConcreteProductA
   └── ConcreteProductB
```

#### 4. Advantages and Disadvantages of Factory Method

| Advantage                  | Description                        |
| -------------------------- | ---------------------------------- |
| **Decentralized creation** | Each subclass controls its product |
| **Extensible**             | Add new types via new subclasses   |
| **Supports OCP**           | No need to modify existing code    |
| **Framework-friendly**     | Great for libraries/SDKs           |

| Drawback                 | Explanation                  |
| ------------------------ | ---------------------------- |
| **Class explosion**      | One creator per product type |
| **Complexity**           | Overkill for simple cases    |
| **Inheritance required** | Forces class hierarchy       |

#### 5. Python Tip: Use `@classmethod` for Simple Cases

```python
class Button:
    @classmethod
    def create(cls, os_type):
        if os_type == "windows":
            return WindowsButton()
        elif os_type == "mac":
            return MacButton()
```

But this is **Simple Factory**, not **Factory Method**.

